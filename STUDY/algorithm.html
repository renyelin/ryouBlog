<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]>      <html class="no-js"> <!--<![endif]-->
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>ryouの算法abondon史</title>
        <link rel="icon" href="">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="../css/goods.css">
        <link rel="stylesheet" href="../css/picture.css">
        <link rel="stylesheet" href="../css/searchButton.css">
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="#">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->

        <form name="f1" action="" onSubmit="if(this.t1.value!=null && this.t1.value!='')
        findString(this.t1.value);return false">
            <input type="text" name=t1 value="" size=30 placeholder="What are you looking for?">
            <input type="submit" name=b1 value="Find">
        </form>

        <b style="font-size: 100px;"><a href="../index.html" target="_self" style="color: #000;">ryou</a>の算法abondon史</b>
        <div class="goods">导航：</div>
        <div class="goods">
            <b>基础</b>
            <li>next_permutation：C++中的全排列函数；</li>
            <li>to_string()：数字转字符串；</li>
            <li>memset：赋值数组，memset(arr,0,sizeof(arr))；</li>
            <li>iota：iota(v.begin(),v.end(),1)，批量递增赋值vector的元素</li>
            <li>priority_queue&lt;Type, Container, Functional&gt;：Type 为数据类型，Container为保存数据的容器，Functional 为元素比较方式，less&lt;Type&gt; 代表从小到大，greater&lt;Type&gt; 代表从大到小；无参数则默认为大顶堆；</li>
            <li>ranges::lower_bound(vtc,target)：二分查找，返回数组中第一个大于或等于被查数的值的迭代器；</li>
            <li>decltype(auto)、typeid: decltype只做参数，不会求值；</li>
            <li>multiset&lt;int&gt;：元素可重复</li>
            <li>s.find（str）：查找子串，返回子串的起始位置，如果没找到，返回标识string::npos；</li>
            <li>stoi() 和 atoi()：字符串转数字；</li>
            <li>substr()：</li>
        </div>

        <div class="goods">
            <b>数据结构</b>
            <li>块状链表：<img src="pic/kuaizhuanglianbiao.png" alt="" style="height: 200px;width: auto;"></li>
            <li>广义表：每个原子是一个有序数列（比如3*(x^2)*(y^4)*(z^5)的各个数字的存储）<br><br>&emsp;&emsp;<img src="pic/guangyibiao.png" alt="" style="height: 200px;width: auto;"></li>
            <li>十字链表：Orthogonal linked list在Linux内核中应用广泛。具体说，一个二维十字链表是链表的元素同时链接左右水平邻结点与上下垂直邻结点。这一方法可以推广到更高维以存储稀疏矩阵、图等数据集合。</li>
            <li>舞蹈链：可以理解为双向环形十字链表</li>
            <li>01字典树：</li>
        </div>

        <div id="algorithm">
            <p>算法</p>
            <div class="goods">
                <b>排序</b>
                <li>插入排序</li>
                <li>桶排序：用桶记录一个数的出现次数</li>
            </div>
        </div>

        <div class="goods">
            <b>标准库算法</b>
            <li>erase：在set、list、unordered_map等容器中时间复杂度为O(1)，在vector、deque等容器中时间复杂度为O(n);</li>
            <li>move：移动元素，减少拷贝，提高效率（针对在堆上分配内存）;</li>
            <li>find：在set、list、unordered_map等容器中时间复杂度为O(logn)，在vector、deque等容器中时间复杂度为O(n);</li>
            <li>sort：排序，时间复杂度O(nlogn);</li>
            <li>lower_bound：在有序数组中查找元素，返回其位置，时间复杂度O(logn);</li>
            <li>upper_bound：在有序数组中查找元素，返回其位置，时间复杂度O(logn);</li>
            <li>binary_search：在有序数组中查找元素，返回bool值，时间复杂度O(logn);</li>
            <li>next_permutation：生成下一个排列，时间复杂度O(n);</li>
            <li>reverse：反转容器，时间复杂度O(n);</li>
            <li>min_element：返回容器中的最小值，时间复杂度O(n);</li>
            <li>max_element：返回容器中的最大值，时间复杂度O(n);</li>
            <li>accumulate：累加求和，时间复杂度O(n);</li>
            <li>count：返回容器中元素的个数，时间复杂度O(n);</li>
            <li>contains()：C++20, map判断key是否在容器中</li>
        </div>

        <div class="goods">
            <b>编程算法思维</b>
            <li>位运算与集合：将一个集合被表示为二进制数，且位运算符合集合运算；</li>
            <li>超图（hypergraph）：图的一种扩展，允许边有多个端点；</li>
        </div>

        <div class="goods">
            <b>算法与个人理解</b>
            <li>x>>1：位运算实现除以二；</li>
            <li>x&(x-1)：位运算实现取最低位1；</li>
            <li>Morris 中序遍历 O(n),O(1)：设置predecessor指针，将叶节点的右指针指向下一个应该访问的中节点;</li>
            <li>KMP：substr()的实现，字符串匹配算法，时间复杂度O(n+m)，n为待匹配字符串长度，m为模式字符串长度；</li>
            <li>bellman-ford：n-1次重复relaxation，时间复杂度O(mn);</li>
            <li>dijkstra：适合点少边多的稠密图，时间复杂度O(ElogV)，<a href="https://leetcode.cn/problems/network-delay-time/solutions/2668220/liang-chong-dijkstra-xie-fa-fu-ti-dan-py-ooe8/"><b>这是一个链接</b></a></li>
            <li>A*：相当于dijkstra算法加上启发函数，先猜一个估计的最短路径长度y(n)，当y(n)=0时，即为dijkstra<a href="https://zh.wikipedia.org/wiki/A*%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95"><b>这是一个链接</b></a></li>
        </div>

        <div class="backtop">
            <img src="../pic/backtop.png" alt="" height="100px">
        </div>

        
        <script src="../scripts/backtop.js" async defer></script>
        <script src="../scripts/searchButton.js" async defer></script>
        <script src="" async defer></script>
    </body>
</html>